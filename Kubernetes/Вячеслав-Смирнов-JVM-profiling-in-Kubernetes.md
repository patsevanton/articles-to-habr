# **Вячеслав Смирнов. Профилирование JVM в Kubernetes**

Вариантов и инструментов профилирования JVM много, так много, что обо всех и не рассказать. И каждый имеет свои особенности, плюсы и минусы.

Вячеславу повезло использовать разные инструменты. И повезло найти разные дефекты микросервисов на основе JVM. Спикер проанализировал, разделил инструменты и дефекты микросервисов на группы, и хочет рассказать о:

 - подборе профайлеров и их настройках под задачу;
 - собранных рецептах профилирования JVM в Kubernetes;
 - моментах, когда профилирование вредит, а когда помогает.



-   (Сергей Бойцов) Я бы хотел начать с легкого, разгоняющего вопроса. Микросервисы и Kubernetes – это наша новая реальность. Вы согласны с этим?

-   (Вячеслав Смирнов) Скорее всего, да. Микросервисы есть сейчас почти во всех проектах так или иначе. Их выделают, даже если это большие сервисы, т. е. макросервисы, упакованные в контейнеры и раскатанные с помощью Kubernetes, чтобы они лучше масштабировались. Все равно их называют микросервисами. Так что эта новая реальность. 

-   (Владимир Ситников) Я вижу, что люди движутся и в одну, и другую сторону. Кто-то движется в сторону разделения, кто-то уже попробовал и движется в противоположную сторону, поэтому предсказывать, что будет через 5-10 лет я бы не стал. Я бы Вячеславу задал бы следующий вопрос. Когда был один монолит, то его как-то разработали, потом администраторы устанавливали и единороги-нагрузочники тестировали под нагрузкой. Когда делят на микросервисы, команды говорят, что мы сами с усами, все сами сделаем, все сами протестируем и не приставайте к нам. Слава, когда возникает Kubernetes, там нагрузочники вымирают или нет?

-   (Вячеслав Смирнов) Не совсем. Есть множество технологий, которые обещают, что тестирование производительности не понадобится, но тестирование производительности нужно и профилирование в том числе, как некий такой следующий шаг после того, как вы получили результаты и они вам не понравились. Этот этап все равно остается. И о нем я как раз хочу рассказать.

-   (Сергей Бойцов) Здорово! Давайте тогда послушаем. Очень интересно. Задавайте вопросы в Телеграм-чат, чтобы что-то узнать, чему-то научиться. Потому что самое плохое – это незаданный вопрос. 

-   (Вячеслав Смирнов) Начнем.

![](https://habrastorage.org/webt/hn/ko/y8/hnkoy8r68jeazhjtozsvwrxx5me.jpeg)

Я вам расскажу про профилирование JVM в Kubernetes. Я назвал этот доклад «Три больших шага». Меня зовут Вячеслав и я из ВТБ.

![](https://habrastorage.org/webt/no/yo/14/noyo14dncvmsz8etcbvlykvddqc.jpeg)

В ВТБ занимаюсь тем, что исследую и создаю результаты нагрузки. Проект у меня называется ДБО. Если вам интересно, то зайдите на сайт vtbbo.ru.

Кроме работы занимаюсь развитием чата @qa_load, где помогаю инженерам. Помогаю я не один. Там мы делимся опытом. Отвечаем на вопросы тех, кто впервые начал заниматься тестированием производительности. У них вопросов много. Мы общаемся достаточно дружелюбно. 

![](https://habrastorage.org/webt/pa/ce/ll/pacellg1cksokuumrupaltjwpmy.jpeg)

Проект, который мы нагружаем, можно описать в двух словах. Это 100 Java Virtual Machines, работающие друг с другом и с базой данной. Это так на тестовом стенде. 

На продуктивном стенде он гораздо мощнее, он геораспределенный. Там более 200 микросервисов. С учетом геораспределения можно сказать, что даже более 400, но они так или иначе совпадают с тем, что есть на тестовом стенде. 

Доклад посвящен как раз профилированию на тестовом стенде, где вам можно в любой момент перезапустить поду, поменять какие-то настройки, поэкспериментировать, поэтому он пригодится в таком случае. 

![](https://habrastorage.org/webt/-8/eu/te/-8eute6bkrpgmrwly6qrungumwu.jpeg)

Расскажу про особенности профилирования JVM в Kubernetes. Что же именно добавил Kubernetes? 

![](https://habrastorage.org/webt/fy/vw/qn/fyvwqnlxidncyzyl5yf29pkh9zo.jpeg)

Kubernetes добавил выделение ресурсов для нужд профилирования: что есть различные requests, есть различные лимиты и об этом надо помнить.

![](https://habrastorage.org/webt/aq/cm/hi/aqcmhi1x4ii3mja-gzsilztu8u0.jpeg)

Расскажу о том, как выполнять анализ результатов, как перейти от анализа потоков к детализации что же в этом потоке выполняется и перейти на код. 

![](https://habrastorage.org/webt/at/_d/qg/at_dqghy94xma1hxtqnvrucxpdm.jpeg)

Тут будет интересный момент, как оценить взаимодействие микросервисов. Например, есть медленно работающий запрос. Он работает медленно, потому что мы ждем ответа от другого сервиса.

![](https://habrastorage.org/webt/bw/9z/v7/bw9zv7quv5invqoahxjiwnxc5t0.jpeg)

И расскажу, как стандартизировать процесс профилирования в большой команде. У нас в команде 6 человек. Ее уже можно назвать большой командой. Я не везде такие команды видел. Тут уже требуется масштабирование. 

![](https://habrastorage.org/webt/n6/yb/0i/n6yb0i_cemtrulu9t-swaq7l7z0.jpeg)

И следующий этап – это обмен знаниями, т. е. как масштабировать, как обменяться знаниями, как стандартизировать все, чтобы процесс мог выполнять любой человек на любом количестве контуров, пусть у вас даже 3 Kubernetes-кластеров.

![](https://habrastorage.org/webt/jq/fx/lg/jqfxlgdqjt-g6lu0tltbx1hshpw.jpeg)

Доклад можно представить, как сложный пазл. И мы по кусочкам будем его собирать. Расскажу про мелкие детали и про крупные блоки. 

![](https://habrastorage.org/webt/rg/dl/wy/rgdlwydjpktsp3qdjoe7zb2rob4.jpeg)

Начнем с первого этапа. Какие есть в Kubernetes особенности при профилировании? Что он добавляет сам Kubernetes в весь процесс?

![](https://habrastorage.org/webt/ue/uc/vr/ueucvr86lmuossfg2c3zqfzdzry.jpeg)

Раньше мы проводили два вида тестирования: нагрузочный и стабильности, т. е. находили максимум во время нагрузки. И во время стабильности подтверждаем, что в найденном максимуме 8-10 часов держится система и не падает.

А теперь, как минимум, нужно еще тестирование масштабируемости.

![](https://habrastorage.org/webt/1f/6l/qb/1f6lqbeawdsvhb31ql_xujtfioo.jpeg)

После того, как вы провели 3 вида тестирования, во всем этом есть еще одна особенность. Заказчику интересно уже не только число, что мы достигаем такой-то производительности. Важен и второй фактор. Заказчик спрашивает: «Сколько реплик сервису нужно? Какие настройки нужны? Сколько ресурсов нам нужно на кластер, чтобы все это работало достаточно производительно». Т. е. появляются дополнительные вопросы. 

![](https://habrastorage.org/webt/rs/sg/gk/rssggk75w04ddavxozg43awhzie.jpeg)

Самый легкий – это вопрос настроек, т. е. мы ничего не масштабируем, а меняем настройки. Поменяли некоторые конфигурации и все стало быстрее. 

![](https://habrastorage.org/webt/em/tx/z2/emtxz2pxcgyzmabgmqv7h804zpw.jpeg)

Если мы настройками справиться не можем и натыкаемся на то, что на тестовом стенде закончились ресурсы, то появляется интересная задача – ускорение всей этой системы. 

Мне очень повезло. Я попал в команду ВТБ, когда как раз этих ресурсов не хватало, и команда занималась ускорением. Поэтому я набрался опыта по ускорению Kubernetes-кластера. И первое время занимался не столько рутинной работой по запуску тестов, сколько профилированием. И могу поделиться этим. 

Когда вы начнете ускорение, сначала нужно посмотреть на результаты мониторинга, на логи. И, предположим, вы по результату мониторинга, по логам, по высокоуровневым метрикам не смогли найти способ оптимизировать систему. Условно, есть у нас кластер, 10 серверов. В него влезает 100 сервисов. Зафиксировали, промониторили и так ничего не смогли найти. 

![](https://habrastorage.org/webt/ci/cw/r8/cicwr8ggfvoj9d1htdfhbksfrw8.jpeg)

Тогда уже можно подключить профайлер. Можно не сильно масштабировать. И можно посмотреть изнутри JVM с помощью профайлера изменение каких настроек нам сможет помочь все это ускорить и сократить ресурсы. 

![](https://habrastorage.org/webt/-5/66/vo/-566vo__nnajd120lysm07mzn90.jpeg)

Я несколько раз сказал уже о настройках. В Kubernetes принято увеличивать производительность системы очень просто, т. е. увеличивать количество реплик. Считается, что 2 реплики работают быстрее, чем одна. Но на самом деле нет. 

Есть способ не увеличивать количество реплик, а увеличивать количество потоков внутри каждой реплики. Если мы говорим про JVM, то тут, как правило не однопоточное приложение, а многопоточное. 

![](https://habrastorage.org/webt/pz/xy/jo/pzxyjoozcc7iqxdc7ilye3orus0.jpeg)

Я написал несложный алгоритм, чтобы понять нужно ли нам сейчас реплики увеличивать или нет.

Если у нас приложение однопоточное, но упакованное в Kubernetes и у нас нет возможности количество потоков изменить, то чтобы его масштабировать, будем увеличивать количество реплик. И это черный прямоугольник снизу. 

А если количество потоков можно менять, то стоит попробовать их увеличить или уменьшить, т. е. как-то настроить, чтобы добиться лучшей производительности. 

Если производительность при этом увеличивается и после увеличения пула потоков у нас все еще есть свободные ресурсы, то можем этот процесс повторять до тех пор, пока мы не упремся в лимит нашего контейнера, в лимит нашей поды.

И когда мы уже уперлись в лимит нашей поды (можем создавать там 2-3-4 поды), то мы знаем, что для 50 потоков нужна такая конфигурация. 

![](https://habrastorage.org/webt/eb/ai/lu/ebailuzkmgbw455pa4avsqrti3u.jpeg)

При увеличении количества реплик аналогичная ситуация. Если мы изменяем количество реплик, и становится быстрее, и при этом у нас еще есть свободные ресурсы, то мы можем этот процесс наращивать, т. е. проводить тестирование масштабируемости.

А если мы увеличиваем количество реплик, например, сделали вместо одной две, но быстрее не становится, то это второй момент, когда нам нужно подключить профайлер или какие-то другие инструменты, которые нам помогут узнать, почему не становится быстрее. 

![](https://habrastorage.org/webt/69/ck/pk/69ckpkrzaa1bilzcohazqfzeeho.jpeg)

Какие это могут быть инструменты? Это тоже хороший вопрос. В Kubernetes не все так однозначно. Иногда Kubernetes JVM профайлер не нужен.

![](https://habrastorage.org/webt/lt/ma/wx/ltmawxervogkegzhaz-guekjcms.jpeg)

1. Есть цикл тестирования, где мы сначала проводим регрессионный тест, т. е. просто сравниваем. Например, была версия 1, у нее производительность стала версия 2. И ее метрики в JMeter, Gatling сравниваем. И можем определить узкое место, если видим деградацию по той дельте изменений, которая была между версией 1 и версией 2. И даже можем определить место, которое сильнее всего тормозит. 
2. Если нужно копнуть глубже, то нужно посмотреть на статистику балансировщика нагрузки, детализацию по логам ошибок, если вдруг в новой версии появились ошибки. 
3. Можем посмотреть на бизнес-метрики производительности. Например, посмотреть в Яндекс.Метрике, Google Analytics, как там пользователь на prod’е чувствует себя. В нашем проекте есть встроенные метрики внутренней производительности.  
4. Кроме этих метрик, как правило, во всех Kubernetes-инсталляциях есть такие сервисы, как Zipkin, Jaeger, которые собирают статистику за счет трассировки запросов при передачи их от микросервиса к сервису. Это более детальная статистика, чем даже в самом JMeter. 
5. Кроме того, не стоит забывать про мониторинг системных метрик. 
6. Мониторинг более внутренних метрик, например, внутри JML, SQL
7. И если после всего этого объема информации вам недостаточно, то тогда 7-ым этапом можно запрофилировать JVM. 
8. Профилировщик сможет найти не все. Иногда в моей практике пригождаются утилиты strace, perf и другие, которые позволяют найти то, что изнутри JVM не видно. 

![](https://habrastorage.org/webt/ut/yp/sy/utypsyb5bqbndmilhkg7_yi-xnw.jpeg)

Если это визуализировать как-то в картинку, то визуализацию я смогу для вас изобразить вот такую. 

Вот у вас есть браузер, т. е. клиент. Этот браузер обращается к вашему сервису. Он представляет из себя 4 сервиса переднего уровня и там есть 100 микросервисов на бэке. 

И нам нужно определить, какой микросервис самый медленный. 

![](https://habrastorage.org/webt/me/nl/ec/menleca841tcol15pzhtkoptijm.jpeg)

Чтобы это определить, нам не обязательно использовать профилировщик. Нам хватит отчета по нагрузке. Т. е. такая статистика будет в JMeter, Gatling. А также бизнес-метрики или даже статистики по логам. В том же nginx можно настроить детальное логирование. 

![](https://habrastorage.org/webt/8b/2r/qu/8b2rquowmcgk7zjs3f7ctqqip3g.jpeg)

Предположим, вам нужно определить, при каких параметрам этого запроса данный микросервис более медленный.

![](https://habrastorage.org/webt/d0/0t/fo/d00tfocuhv-mppwu4m0ry-ongtq.jpeg)

Это в отчете по нагрузке, если вы эти параметры использовали или в более детальных логах. Там можно уровень логирования поднять и узнать все детали, т. е. какой же параметр приводит к замедлению. 

![](https://habrastorage.org/webt/z7/r2/6b/z7r26b02hn-uawasgkfbssbsope.jpeg)

Если бы у нас был монолит, мы бы тыкали в какую-нибудь url монолита и желали узнать, что внутри приложения тормозит, т. е. какой модуль, компонент, то, скорее всего, мы бы взяли профайлер. 

![](https://habrastorage.org/webt/fz/cd/8g/fzcd8g9zai1ux-dch6rtt2wz5ms.jpeg)

Мы бы профилировали этот монолит и сказали, что тормозит. 

![](https://habrastorage.org/webt/ad/b4/o1/adb4o1q66jgx0afilusmault95w.jpeg)

А с микросервисами не так все просто. Нет единого исполняемого файла. У нас целая россыпь микросервисов. Они общаются друг с другом. Каждый из них может самостоятельно ходить в базу и другие системы. 

![](https://habrastorage.org/webt/rl/fj/mv/rlfjmvtlu7czo866k0reyekmpxq.jpeg)

И тут очень полезными являются инструменты Zipkin и Jaeger, которые трассируют запросы между сервисами и предоставляют полезную статистику. 

 О чем я? О том, что профайлер нужен не всегда. Иногда могут пригодиться и другие инструменты, чтобы закрыть все ваши нужды. 

![](https://habrastorage.org/webt/r2/zr/_q/r2zr_qyrsnbxforlbmsf6uvf09q.jpeg)

Чуть ранее я упоминал о особенности Kubernetes, что при начальном масштабировании мы можем увеличивать количество потоков.

Но бывает и обратная ситуация, когда потоков внутри нашего приложения изначально очень много, т. е. больше, чем нужно. И если мы занялись профилированием, и мой доклад об этом, то расскажу вам, как влияет количество ненужных потоков на эффективность профилирования. 

![](https://habrastorage.org/webt/jx/ww/4a/jxww4at_gvfph3dyxu5nvheoqum.jpeg)

Самый частый способ профилирования, который использую я, это вычисление процента активности того или иного метода. Делается это, как правило семплированием. 

В JFR, SJK, AsyncProfiler, JVisualVM и т. д. есть режим семплирования. 

![](https://habrastorage.org/webt/ez/eo/bi/ezeobiclkpy1rtwsw7plzhmmfai.jpeg)

Если вы не знаете, что это такое, то вы наверняка знаете, что такое Stack Trace. Видели это в логах или в различных инструментах. Это последовательность вызовов Java-методов. 

![](https://habrastorage.org/webt/xg/gs/cc/xggsccv90e3ydb1_-wfsq0u1wfs.jpeg)

И если накопить статистику по этим Stack Trace, то можно что-то понять. Например, вот у нас 4 раза метод putVal, 8 раз метод sample в строчке 613. 

![](https://habrastorage.org/webt/7s/xm/a5/7sxma5tbbst7xvkh7z6ohyjctro.jpeg)

Я накапливаю, накапливаю и получаю статистику, какие методы у меня более часто встречаются во время работы потока, какие менее часто. 

![](https://habrastorage.org/webt/hx/eq/iy/hxeqiyh3u2li6ztyk9_seazgvyi.jpeg)

И как на сбор этой статистики, т. е. на процесс семплирования, влияет количество потоков? Чтобы это определить, я собрал небольшой тестовый стенд. У меня был один сервис, принимающий запросы по http. В нем можно было менять количество потоков от 200 (по умолчанию) до 5. И использовать JMeter, который подавал нагрузку всего лишь тремя потоками. Т. е. чтобы со всеми этими запросами справится, сервису достаточно тоже всего лишь 3 потока у себя. Все остальные спали и ждали, когда к ним перепадет запрос и перепрофилироваться с помощью SJK.

![](https://habrastorage.org/webt/0t/fg/bg/0tfgbg5j69e6hkcsmwxofzb6m9k.jpeg)

Какие результаты я получил? Получил такие результаты, что запросы в среднем выполнялись 100 миллисекунд. Самые тяжелые методы – 10 миллисекунд. 

![](https://habrastorage.org/webt/dw/my/vz/dwmyvz-0afchhl4zuousixldfh8.jpeg)

И когда у меня было 120 лишних потоков, то SJK, профилируя все активные потоки, в том числе 120 спящих, собирал метрики с интенсивностью 90 раз в секунду. Получается, что в среднем каждые 11 миллисекунд он лишь собирал stack trace. 

При такой интенсивности он мог легко пропустить Java-методы, которые работают даже в среднем быстрее. 

![](https://habrastorage.org/webt/zt/9j/do/zt9jdolj-2ob45jrzlxilqpjjtg.jpeg)

Конечно, он ловит все http-запросы, т. е. кто их отправляет и как долго ждет, а Java-методы может легко пропустить. 

![](https://habrastorage.org/webt/v_/cr/hq/v_crhqlaf2mkeqp3t4nfiydzxd8.jpeg)

Если снизить количество потоков до 20, оставить только 20 спящих, то частота семплирования гораздо выше становилась. И уже интервал семплирования снижался до 3 миллисекунд. Это значит, что туда попадали даже те методы Java, которые быстрее, чем средние. 

![](https://habrastorage.org/webt/ko/zb/z2/kozbz2nh_164ot54ppj1vzjgd5i.jpeg)

Результаты можно представить на таком графике. 

![](https://habrastorage.org/webt/6a/by/tu/6abyturr-ucm3avblx9j2gjybog.jpeg)

Я провел серию замеров. 

![](https://habrastorage.org/webt/ec/dp/rx/ecdprxigdzbocka_ie5edcfwsdi.jpeg)

Если снизить количество потоков со 120 до 20, то у нас интенсивность семплирования повышается в 3 раза.

![](https://habrastorage.org/webt/hl/ch/ha/hlchhadip95mvx6lde19gvo7c5s.jpeg)

А по умолчанию tomcat.mat-threads – это 200 потоков. 

Если постепенно снижаться с 200 до 5, то интенсивность повышается в 5 раз. Это о том, что не только увеличение количества потоков полезно. Для задач профилирования снижение – это тоже интересный момент, хоть и неочевидный.

![](https://habrastorage.org/webt/dk/3i/9g/dk3i9guxkkh1cde_zjbkdrbk7vu.jpeg)

Какая получалась частота семплирования в SJK? Я измерял с помощью команды ssa, которая есть в SJK. Это Stack Analyzer. Выводил колонку интенсивности, которая получилась. И смотрел, что по интенсивности получается. В данном случае почти 60 раз в секунду.

![](https://habrastorage.org/webt/5d/ij/ix/5dijixusurfrqnkpk--rr4zv40w.jpeg)

Следующей особенностью в Kubernetes является влияние CPU Limit на профилирование и на сам процесс профилирования. 

![](https://habrastorage.org/webt/d-/tl/tw/d-tltwba3ewxip9b5ma82iog7wk.jpeg)

Я использовал тот же самый стенд, но в нем ограничил возможности использования процессора данным сервисом до 1 ядра. 

![](https://habrastorage.org/webt/xe/ny/fu/xenyfuuixezdfu-ijy16tivghyi.jpeg)

Получились следующие результаты. Когда я не ограничивал, то я собирал интенсивность метрики 90 раз в секунду, а как ограничил, и весь сервис замедлился, то интенсивность профилирования снизилась. Стало всего лишь 7 раз в секунду. И с такой интенсивностью я не поймаю различные супербыстрые метрики. Т. е. при неправильной настроенном лимите и запуске профилирования можно хорошие метрики не собрать.

![](https://habrastorage.org/webt/nr/4k/0g/nr4k0gjy_cm5abykzmeh5cx1x94.jpeg)

Примеры показали, что SJK на большом количестве потоков затрачивает где-то 0,36 ядра. Об этом надо помнить. 

![](https://habrastorage.org/webt/ac/-a/bw/ac-abwzfp_kwlr-myugumevx6-k.jpeg)

И если вы начали профилирование в Kubernetes, то чуть-чуть добавьте для накладных расходов самого профайлера CPU, т. е. поднимите лимит. 

![](https://habrastorage.org/webt/je/jp/vp/jejpvpqi6ba_kh5cktlhoqlk2nw.jpeg)

Если вы не можете поднять, то можете просто снизить интенсивность семплирования. Это настраивается во всех профайлерах. В JVisualVM, например, интенсивность семплирования по умолчанию 100 миллисекунд. И такую же интенсивность можно задать во всех других профайлерах. Но в этом случае вам нужно будет профилировать чуть подольше. Не 10-30 секунд, а, например, 10 минут профилировать.

![](https://habrastorage.org/webt/bz/3d/_x/bz3d_xjbzgvmq5b1hdvjrcxadxm.jpeg)

Кроме CPU Limit в Docker и Kubernetes есть Memory Limit. Он также влияет на профайлер, но уже на другие. 

![](https://habrastorage.org/webt/ur/zj/pr/urzjprtm956dvkebbpdqmixc4da.jpeg)

Здесь несколько иная задача профилирования. Задача посчитать не просто процент активности, а посчитать точную длительность и количество выполнений каждого метода. И это позволяют уже выполнить инструментирующие профайлеры. 

Среди тех, которые я успешно пробовал, могу назвать JVisualVM. В режиме Startup Profiler его можно подключить и запрофилировать в таком инструментирующем виде. А также JProfiler и YourKit Java Profiler.

![](https://habrastorage.org/webt/iw/n8/gz/iwn8gzq1_-zikndj9kslg1zc7g8.jpeg)

Что такое инструментация? Если ее описывать в виде схемы, то это непростой процесс при работе с JVM профайлером. Например, для C проектов инструментация есть на уровне компилятора. В <font color="red">JCC</font> вы можете заинструментировать компилируемый код и получить там какие-то метрики. И все эти метрики будут на уровне исходников туда вшиты, и выполняться до запуска. 

А при JVM инструментации более популярен подход на лету с помощью JVM-агентов, когда меняется JVM Byte-код. Это уникальная фишка JVM. 

![](https://habrastorage.org/webt/br/_z/qv/br_zqvbb1zfcxqojjp-glpnvwqo.jpeg)

Когда ваше приложение запустилось, в нем уже 1 000 классов, различные объекты, и вы начинаете каждый класс перелопачивать, т. е. до запуска каждого метода вставлять некий быстрый, но все же код, то это все потребует дополнительных расходов памяти. 

![](https://habrastorage.org/webt/fk/d5/v5/fkd5v53vfw535q-s6kcanqbhipw.jpeg)

И сам процесс инструментации потребует дополнительных расходов процессора. 

Мы сталкивались в команде с такими эффектами, что приложение падало из-за недостатка ресурсов памяти, если сделали вот такое инструментирующие профилирование. 

![](https://habrastorage.org/webt/ez/sd/qu/ezsdqu_gsg5t2tv7rguza6tnx7y.jpeg)

Тут общая рекомендация, что если вы запускаете еще инструментирующее профилирование с помощью JVM-агента, то добавьте себе в поду немножко памяти тоже. 

Если вы явно не влияете в вашей поде на размер heap size, т. е. Xmx, а влияете только на лимит. Например, Xmx вычисляется с помощью MAX_MEM_RATIO, есть такая опция в некоторых контейнерах. И чтобы добавить 1 гигабайт, вам нужно лимит поднять на + 2 гигабайта. 

![](https://habrastorage.org/webt/mf/mh/ag/mfmhagbahjpvucxqhhuhmdp3mom.jpeg)

Так или иначе помните, что нужно добавлять ресурсы, если вы делаете тяжелое профилирование. 

![](https://habrastorage.org/webt/xg/dw/gw/xgdwgwqbitjwambd7m5xey00nhw.jpeg)

Почему это важно? Что это за такие ресурсы? Можно описать это двумя словами.

![](https://habrastorage.org/webt/vp/bb/sf/vpbbsfxd4iimvon-fumqlrdbpe0.jpeg)

Вот здесь request, т. е. внутренняя граница контейнера. И есть лимит – внешняя граница контейнера. 

Для контейнера можно задавать только request – это первая картинка. И делать его изначально маленьким. 

Можно задавать маленький request и достаточно крупный лимит – это вторая картинка. 

Некоторые выбирают стратегию, когда request практически равен лимиту и он изначально большой. 

Некоторые выбирают, когда request огромный, а лимит не задан. Это для тяжелых гибких сервисов.

![](https://habrastorage.org/webt/oc/7k/ty/oc7ktyjyeruv_87sntqhaurbfag.jpeg)

А рекомендация – накинуть 1 гигабайт и 1 гигабайт CPU. 

![](https://habrastorage.org/webt/ob/ok/nk/oboknkoqudqd65v8ct-ra6gajke.jpeg)

Что будет, если мы не накинем и у нас есть вот такая инсталляция, где есть профилируемые сервисы и в двух из них лимиты не заданы? 

![](https://habrastorage.org/webt/el/7e/og/el7eog7bhmsoo6uqfpfae85uvf0.jpeg)

Сначала они будут маленькими. Под нагрузкой, конечно, сервисы начнут потреблять больше ресурсов.

![](https://habrastorage.org/webt/su/wm/cy/suwmcynefsoiton-igolgkiwsqk.jpeg)

И вот они все выросли.

![](https://habrastorage.org/webt/ju/ls/b7/julsb7wg_ofa81vx_9ayoi9ujjg.jpeg)

И первому центральному сервису стало не хватать ресурсов.

Если ему не хватает CPU, то ничего страшного не случится. Как я вам рассказал, интенсивность семплирования снизится, т. е. она застынет на какой-то планке. Возможно, это будет даже 7 sample  в секунду, но ничего не случится.

А если так случилось, что в приложение выделено heap в 2 гигабайта, а у нас физически на кластере остался один гигабайт памяти, то JVM будет думать, что ей можно выделить столько памяти, а физически столько памяти нет. И контейнер, т. е. приложение упадет по out of memory error. В этом случае весь контейнер схлопнется и перезапустится. Там начнется все с начала. 

![](https://habrastorage.org/webt/xv/cw/5u/xvcw5un_udsqedu0kc3gu0p5quq.jpeg)

Но процесс профилирования прекратиться, т. е. что-то разломается, сессию с профайлером мы потеряем.

![](https://habrastorage.org/webt/jf/py/es/jfpyes6uch7_fhwdjkf6s84rbiw.jpeg)

Второй случай, если у нас лимит задан, но не у всех. Сначала тоже будет все хорошо. 

![](https://habrastorage.org/webt/bl/jn/9l/bljn9lh1kxy3d3zuvhueg8febwm.jpeg)

Мы начнем подавать нагрузку. 

![](https://habrastorage.org/webt/yj/dx/2s/yjdx2sbj7xwq3s6vitbc4l8m3ji.jpeg)

Контейнеры начнут потреблять больше ресурсов. 

![](https://habrastorage.org/webt/vw/rg/z-/vwrgz-ohzmw4plbkxmhdpzuqdpq.jpeg)

И может так случиться, что одному из контейнеров, у которого лимит задан, ресурсов будет не хватать. 

Тут важный момент проявляется в особенностях самого Kubernetes. 

![](https://habrastorage.org/webt/wg/nh/k2/wgnhk2qrqb4gb4a26lwnuejxfw8.jpeg)

Если ресурсы можно выделить Kubernetes’у за счет того, чтобы погасить какие-либо сервисы, у которых ниже приоритет, чем у текущего, а если у нас лимит задан и приоритет выше, то Kubernetes так и поступит. Он возьмет другую поду, у которой лимит не задан и погасит ее, перезапустит ее. 

![](https://habrastorage.org/webt/gd/tb/su/gdtbsu9k3ufavyzkeb3cdxjmrsk.jpeg)

В этом случае данная пода не сломается, она получит свои ресурсы, но, возможно, сломается что-то еще. Сервис контроля доступа и профилирование или весь процесс все равно разрушатся, потому что что-то пошло не так. 

В случае, если у нас всех сервисов по одной штуке, тогда вообще бизнес-процесс остановится. 

![](https://habrastorage.org/webt/j7/ij/fu/j7ijfurzgva2juo-vtwf8wdiatc.jpeg)

И самый желательный вариант, когда везде лимиты заданы.

![](https://habrastorage.org/webt/xk/a-/e1/xka-e1xa1glk-yh7vymv9y1xmi0.jpeg)

Мы начинаем нагрузку. Сервисы были маленькие. 

![](https://habrastorage.org/webt/mw/yi/xv/mwyixvzc7ouauiyu-v3fsv5j5ve.jpeg)

Вот они стали побольше. 

![](https://habrastorage.org/webt/bk/y8/3m/bky83mem98kkdzv7zvwgl_huhww.jpeg)

И вот им ресурсов не хватило. 

Какой тут вариант? Мы знаем, что этому сервису нужно столько-то ресурсов.

![](https://habrastorage.org/webt/es/vy/ng/esvyngwjwqij_fua2wtdkzehvjy.jpeg)

И при профилировании накидываем чуть-чуть. 

![](https://habrastorage.org/webt/ci/ql/te/ciqltefefdlfb0fbqx8si-oaiu4.jpeg)

Можно 0,3-0,4, можно +1. И все будет работать, как будто бы и не было никакого профилирования. Это такая особенность Kubernetes.

![](https://habrastorage.org/webt/dg/np/lv/dgnplveff9n9r9hkxgpe3dqpbxs.jpeg)

Какие есть особенности у самих профайлеров при работе с распределенными системами?

![](https://habrastorage.org/webt/jy/cc/ef/jyccef_fvympzg2kfup9r2ohp7k.jpeg)

Можно все профайлеры и способы их подключения разделить на 2 больших типа: 

- Мы подключаемся удаленно, т. е. запускаем профайлер у себя на рабочей станции и подключаемся к поде или сервису; 
- Мы подключаемся локально. 

![](https://habrastorage.org/webt/0w/ms/hb/0wmshbf1acm3uidnlupe6gc0tcg.jpeg)

Самый привычный, когда вы запускаете профайлер с графической оболочкой у себя на рабочей станции. Это удаленный вариант. 

В чем его особенности? Его особенности в том, что вам нужно пробросить сетевое подключение от вашей рабочей станции до профайлера, т. е. есть несколько фишек самого Kubernetes. 

![](https://habrastorage.org/webt/-5/9y/g-/-59yg-kunlq-x0fudevwcprhn84.jpeg)

- Предположим, вам нужен доступ до поды лишь на время. Тогда воспользуйтесь kubectl и ее опцией PortForward с пробросом локального порта в поду. 
  -  Если вам нужен постоянный доступ, то проще зафиксировать выставление порта для профилирования из пода наружу, например, задав эти настройки уже в сервисе. 
- Очень удобно делать, если ваш сервис всегда заскейлен в 1. В этом случае вы всегда, начиная профилирование, будете попадать в профилируемую вами поду. 
  -  Это можно сделать через NodePort.
  -  Можно сделать через LoadBalancer.
- А если вы заскейлили сервис в две реплики и хотите сделать тоже самое через внешний порт, то, скорее всего, не получится. 
  -  Потому что ваш профайлер будет обращаться за результатами профилирования в поду. И будет попадать то на первую, то на вторую. И профилирование не получится. Или получится каким-то неправильным. Это единственное такое ограничение.

![](https://habrastorage.org/webt/zu/jw/l_/zujwl_cdori5hc-glk_viw41yfu.jpeg)

Если вы выбрали такой способ, то две техники: с помощью Java-агента и с помощью технологии JSR 160 Standard, где вам нужно открыть два порта: JMX и RMI и пробросить их себе.

![](https://habrastorage.org/webt/yb/bv/xe/ybbvxexf5ssclntovjxgb49vrvi.jpeg)

Расскажу сначала про этот вариант. 

![](https://habrastorage.org/webt/ad/-0/dq/ad-0dq51cb2aap0zrpqkhzc-m0u.jpeg)

Чтобы открыть эти порты JMX, RMI, вам понадобится в опции JVM запускаемого сервиса внутри докера добавить вот такой перечень опций. Как правило, я задаю такие опции в deployment-файле. 

Вот вы открываете порт 9010. Можно и для JMX, и для RMI задать одинаковый порт. В данном случае это не критично. И с помощью kubectl или с помощью другого инструмента взаимодействия с Kubernetes CPI пробрасываете свой порт внутрь поды. 

![](https://habrastorage.org/webt/df/ls/g8/dflsg86nylelxahea1yz0uz9dn4.jpeg)

Если вам нужно запрофилировать и пробросить порты и для сервиса аутентификации и для сервиса генерации отчетов, и для сервиса генерации отчета, то у вас получится такое сделать, если вы во всех подах задали одинаковый порт. Потому что, когда вы будете открывать соответствующий порт у себя на станции, kubectl скажет: «Я не могу дважды открыть порт 9010, он уже кем-то занят».

![](https://habrastorage.org/webt/b7/us/pa/b7uspafftsfom6dramgi53vqd_u.jpeg)

В этом случае вам в другом сервисе нужно отсылать в другой порт. Например, 9011, т. е. какой-то иной. Помните об этом. И нужный порт к нужному подсоединить. 

![](https://habrastorage.org/webt/7f/xw/do/7fxwdox6iwnqbwybojbt-hj0qri.jpeg)

Если вы решили это делать не с помощью таких постоянных действий, как пробрасывание порта, можете зафиксировать порт через NodePort в разделе Service. В этом случае вам в опции JVM нужно прописать именно тот порт, который вы открываете в сервисе. 

И тут последовательность несколько иная. Вы сначала в разделе Service говорите: «Я хочу, чтобы из данного сервиса наружу торчал порт 31111». Если такой порт не занят, то он открывается. Если вы убедились, что он открылся, он зафиксирован и вашему сервису принадлежит, то потом идете в настройки сервиса в раздел Deployment и там соответствующий порт задаете, т. е. в обратном порядке. 

![](https://habrastorage.org/webt/le/-f/xv/le-fxvieyupxz8avmd4xyuhbdua.jpeg)

Если вы никогда работали с Kubernetes-дашбордом, то это Deployments и Service. Т. е. сначала во внешний раздел идете, там настраиваете, открываете порт. А потом в Deployment его указываете. 

![](https://habrastorage.org/webt/vv/q4/29/vvq429gy94jiieflrn5d58bqc3y.jpeg)

Хорошую документацию, где есть инструкции с картинками, что это за порты и как их прокинуть именно из докер-контейнера, описал Алексей Рагозин в блоге компании BellSoft. Это один из разработчиков JVM. Называется «JVM in Linux containers, surviving the isolation». Всем рекомендую прочитать эту статью, если вы пользуетесь таким способом. Она доступна по ссылке, данная ссылочка кликабельная. 

![](https://habrastorage.org/webt/zv/jc/nj/zvjcnjprxdrxqzi4xr8cubihyvw.jpeg)

По такой технологии вы можете подключить различные инструменты: SJK, JMC, VisualVM.

![](https://habrastorage.org/webt/js/fu/po/jsfupouzcard_pajcjjsumtmque.jpeg)

Один из самых простых инструментов – это SJK.

![](https://habrastorage.org/webt/qe/80/6x/qe806x79_tdmgzhd4ueyczcyrx0.jpeg)

Вот вы пробросили порт, потом у себя пишите такую команду, где можете выставить профилирование с ограниченной интенсивностью или с максимальной интенсивностью на 5 минут. 

![](https://habrastorage.org/webt/jy/1s/p4/jy1sp4mugndp0pbbguyslzr81xw.jpeg)

Второй по простоте – это, наверное, JMC и технология Java Flight Recorder. 

![](https://habrastorage.org/webt/my/sa/2d/mysa2depg6p_cuv7uhldaiqnx5a.jpeg)

С ней есть несколько особенностей. Она заключается в том, что технология JFR появилась в OpenJDK в 8-ой не сразу, а только с версией 272.

И если у вас версия 272, то открывайте JMX, RMI также, как для предыдущих инструментов и пользуетесь.

Если у вас старый 8-й OpenJDK, то у вас просто ничего не получится. Вам нужно или монтировать Java в контейнер, или не пользоваться этим способом.

Если у вас Oracle JDK, то там есть еще более тонкий момент. До build 161, даже до build 162 лицензия на Oracle JDK позволяла использовать JFR на тестовых стендах при включении опции UnlockCommercialFeatures и опции FLightRecorder. 

Если у вас более старшая версия, то вам нужно будет купить лицензию. Она исчисляется стоимостью по ядрам. Сам я не использовал такой способ после смены лицензии. 

![](https://habrastorage.org/webt/j5/0u/tz/j50utzpuq7qyw_ujwnqzqaiwdjm.jpeg)

Если вы все настроили, то дальше в Java Mission Control создаете подключение. 

![](https://habrastorage.org/webt/8-/zc/jj/8-zcjjmqxj0qy5oy2mft9ciase8.jpeg)

Указываете порт, который вы открыли. Например, 9010. 

![](https://habrastorage.org/webt/k6/8f/ny/k68fnymw8vhevaq5e0mzyt1h9f4.jpeg)

Открываете JMX Console с помощью Java Mission Control.

![](https://habrastorage.org/webt/6t/po/aa/6tpoaad8yroroy8bludua3vcbh4.jpeg)

Проверяете, что с вашей подой все хорошо и запускаете с помощью пункта Start Flight Recording процесс профилирования.

![](https://habrastorage.org/webt/np/yj/zw/npyjzwk0dluc3y_bxvx2b_frujy.jpeg)

С VisualVM все аналогично. 

![](https://habrastorage.org/webt/_b/nn/iu/_bnniuuplqr8xfjvvkbon17drjs.jpeg)

Вы так же создаете подключение.

![](https://habrastorage.org/webt/_g/9l/an/_g9lanusei-bd9mqxa1ayzc403s.jpeg)

Так же указываете локальный хост и порт после того, как пробросили все. 

![](https://habrastorage.org/webt/48/nl/bo/48nlbooxwpa9zyu9ppdliitx-z4.jpeg)

Открываете. У вас появляется в разделе Local созданное вами подключение. Locolhost 9010 открываете. 

![](https://habrastorage.org/webt/w2/-q/3u/w2-q3u2yh-yjtitckzdi7waexks.jpeg)

И на вкладке Sampler можно начать профилирование потоков, нажав на кнопку CPU.

![](https://habrastorage.org/webt/ok/b9/uh/okb9uhsa2oybftxfqmvdif9mric.jpeg)

Более интересную и, возможно, более детальную информацию можно получить у JavaAgent-профайлеров. 

![](https://habrastorage.org/webt/aq/iw/ur/aqiwurprh48ezo5bbkj9xzf06om.jpeg)

Таких как JProfiler, YourKit Java Profiler. 

![](https://habrastorage.org/webt/b4/xe/s4/b4xes4t8xujivffxydzbq5stmds.jpeg)

Но тут несколько иной способ подключения. Вам нужно доставить и сам профайлер внутрь поды. Вот эти агенты нельзя просто опциями подключить. Это не встроенная возможность Java. Это определенный программный код, т. е. программный продукт, который подключается дополнительно к JVM. И мы в команде такие опции кладем в некий каталог, а каталог монтируем в поду. И потом настраиваем все эти опции, создаем сетевое подключение.

Какие тут преимущества? 

- Всего один порт, нет JMX, RMI. Всего один сетевой порт для агента.
- Можно уже подключаться к двум подам одного сервиса. И у самих этих инструментов более интересный интерфейс.


![](https://habrastorage.org/webt/bj/qx/do/bjqxdogcqvi6demn6e1mgpo8kfu.jpeg)

Расскажу про интерфейс для профайлера. Он достаточно хороший. 

![](https://habrastorage.org/webt/ku/uv/rp/kuuvrprb2o67naigcrzyfvafrlk.jpeg)

Если вы начнете профилировать с ним, то вам понадобится 2 дистрибутива. Один для вашего клиентского рабочего места, например, у вас Windows. 

![](https://habrastorage.org/webt/st/et/bo/stetbon8lvgvo37hqupvm_zikay.jpeg)

Второй дистрибутив, который будет работать внутри поды. Как правило, это Linux. 

![](https://habrastorage.org/webt/6r/pj/zl/6rpjzlejwv7xjmfz-aqqunofeja.jpeg)

Но вам не все файлы из этого дистрибутива понадобятся, а лишь две подпапки. 

![](https://habrastorage.org/webt/hx/ln/rs/hxlnrsbquqdnyggzvjeq0f8c3ng.jpeg)

В случае Alpine Linux папка называется Linux_musl. 

![](https://habrastorage.org/webt/g8/el/af/g8elafdugqfcppidp0m42yuevt0.jpeg)

В случае всех остальных – Lunux-x64.

![](https://habrastorage.org/webt/sw/zk/d9/swzkd90m1tyksfzb8lk0jmw5mey.jpeg)

Узнать, какая у вас ОС используется несложно. Откройте командную консоль для вашей поды и введите туда команду «cat /etc/os-release». Увидите там Alpine, значит Alpine, иначе это что-то другое. 

![](https://habrastorage.org/webt/pq/_l/qk/pq_lqkboysntswre8do-ijzqftg.jpeg)

При подключении агента нужно в deployment смонтировать этот агент, чтобы он появился на диске, т. е. чтобы он был у вас на сервере. Далее смонтировать это в поду. И подключить уже к Java через Java options. Как правило, можно сделать вот таким образом.

![](https://habrastorage.org/webt/zp/26/gv/zp26gvqhwda7tkxmsmicukfiq1m.jpeg)

для CentOS получится тоже самое, только каталог из дистрибутива, который будет подключаться в поду, будет другой, т. е. linux-x64.

![](https://habrastorage.org/webt/5p/jc/wy/5pjcwy5hsbm-qiy8ilmdlulb8to.jpeg)

Особенность тут в том, что если вы подключаете это на несколько сервисов, то настройки можно оставить такие, т. е. сохранить тот же самый порт. Максимум, что будет меняться в зависимости от дистрибутива это musl или x64.

Вы это сделали, сервис перезапустился.

![](https://habrastorage.org/webt/8c/rt/im/8crtimfttv8vscbdqsz-g0d3dra.jpeg)

И вы в JProfiler создаете новую сессию. Про это тоже буду рассказывать, потому что не самый тривиальный интерфейс, можете запутаться.

![](https://habrastorage.org/webt/_n/73/5t/_n735titight87grzx6n-wfyk0w.jpeg)

Пробросили себе порт. Вы говорите, что хотите удаленное подключение, но к своему локальному рабочему месту: 127.0.0.1 и указываете порт, который вы пробросили. 

![](https://habrastorage.org/webt/yd/zh/zc/ydzhzco4sdch6ugvzzh2rxzfrqm.jpeg)

Далее в настройках Call Recording выбрать обычное семплирование. Этот способ называется full sampling, потому что он выполняется максимально быстро, но с дополнительной опцией, что нужно сохранять и номера строчек, чтобы потом это можно было проще смапить на код.

![](https://habrastorage.org/webt/cl/hr/fb/clhrfbd-wgodh8jlcvy7yzc8irm.jpeg)

А дальше в профайлере открываются все его фишки. Он может перехватывать все SQL-запросы с параметрами. Вы видите всю статистику по каждому SQL-запросу.

![](https://habrastorage.org/webt/aq/t9/cf/aqt9cfwqbxwirq4fykssfx0z2pa.jpeg)

А также http-запросы к exceptions, т. е. то, чего нет, например, в JVisualVM. Тут оно есть. 

![](https://habrastorage.org/webt/zq/mh/bp/zqmhbpx49wvzpuevp6ztjspaday.jpeg)

Тут вы подтверждаете, что хотите простое семплирование. 

![](https://habrastorage.org/webt/ej/vt/vh/ejvtvhf5ccmpwjtieaxpxunmxqe.jpeg)

Но и после этого семплирование не запустится. В этом сложность интерфейса. Чтобы запустить вам нужно нажать Start recording. И когда вы попытаетесь в первый раз это сделать, увидите, что все эти опции, которые вы выставили, все равно собираться не станут. 

Нажмите на пункт, что вы хотите настроить новый профиль сбора метрик. 

![](https://habrastorage.org/webt/pe/8y/xy/pe8yxyxmhfuirsygfid2ff20ilo.jpeg)

Назовите его как-нибудь по-своему. Например, что я буду собирать CPU, HTTP, JDBC, Exceptions.

![](https://habrastorage.org/webt/at/wa/f0/atwaf0xgicsozvknt0yeac-liao.jpeg)

Отметьте среди галочек CPU и все, что вы включили при начале сессии. 

![](https://habrastorage.org/webt/_2/4y/h5/_24yh5tmrt1096li6ta2xnallhm.jpeg)

Это будет уже более тяжелое профилирование. И тогда его запускайте.

![](https://habrastorage.org/webt/zx/pr/k5/zxprk564xnimjwbk9gzstf9p07m.jpeg)

Я попробовал так на тестовом стенде и при профилировании в JMeter, и при различных профилированиях <font color="red">миникуба</font>. Мне очень понравился JProfiler. 

Но с использованием удаленного, сложного, долгого профилирования есть один недостаток. 

![](https://habrastorage.org/webt/od/be/u3/odbeu357ttwq2fkjrx821chomh8.jpeg)

Давным-давно мы работали из офиса и не знали таких проблем, как лаганул wi-fi, отвалился VPN. 

![](https://habrastorage.org/webt/rs/jm/7s/rsjm7sxkzbe9oukfwsdvlyo4qxk.jpeg)

А теперь у нас счастливая жизнь, а, возможно, кому-то это и не нравится, когда мы работаем из дома и про все эти проблемы знаем. 

![](https://habrastorage.org/webt/w3/tc/xk/w3tcxkfazbx88vic-ihllo40w4u.jpeg)

И в этом случае удаленное профилирование становится не совсем удобным. Когда вы профилируете через 5 firewalls, то, во-первых, трафик лишний гоняется, во-вторых, может это все прекратиться по независящим от вас причинам.

![](https://habrastorage.org/webt/_z/xh/s8/_zxhs8rlrjaaycfmg3pvfavtlg8.jpeg)

И тут свое применение нашло локальное профилирование. Есть очень много способов его выполнить. 

![](https://habrastorage.org/webt/hl/uy/l9/hluyl9-r0_svf94kidhnsdlkpeo.jpeg)

Один из самых простых – это сделать nginx подключение с помощью SJK, но уже изнутри пода. 

![](https://habrastorage.org/webt/eu/nk/5h/eunk5hgs8w1zb1kv8ynszhhwv3u.jpeg)

SJK (Swiss Java Knife) – это профайлер, разработанный Алексеем Рагозиным. Он очень простой, позволяет подключаться и удаленно, и локально. И он очень маленький, поэтому его можно запускать изнутри контейнера. Это большого overhead не создаст. 

![](https://habrastorage.org/webt/dk/yl/aa/dkylaapdynv_stlpr4obg9znb5s.jpeg)

Кроме того, при запуске из контейнера его опции подключения сильно проще. Можно уже некоторые опции не задавать.

![](https://habrastorage.org/webt/0c/cf/fn/0ccffngbmjuj6sopb4wrdm5vqdi.jpeg)

А задать только те, которые необходимы тоже в Java options.

![](https://habrastorage.org/webt/c6/r7/q3/c6r7q3_h4domw6dkwtignxyumru.jpeg)

Узнать имя пода, который вы хотите профилировать с помощью get pods. Скопировать маленький jar внутрь контейнера с помощью команды cp. И с помощью команды exec собрать результаты профилирования. 

![](https://habrastorage.org/webt/pl/ig/1z/plig1zfp84jshmdbkzjurc8aquk.jpeg)

Все эти опции вы можете записать в командный файл. Вот этот предлагаемый командный файл позволяет уже больший перечень команд выполнять за раз. Позволяет сохранить результаты в tmp/result. 

![](https://habrastorage.org/webt/hw/x7/ua/hwx7uazplk4ijvgy3wdtujrbqc8.jpeg)

И потом с помощью kubectl или других инструментов скачать результаты.

Я делал это следующим образом. Внутри пода захожу в каталог с результатами и упаковываю их в старый архив. Передаю результаты выполнения, т. е. вот этой упаковки, на консоль, на стандартный вывод. Через pipe получаю с консоли уже в своей станции эти результаты. И с помощью того же инструмента tar распаковываю результаты со стандартного вывода в текущий каталог. 

После чего данный каталог можно там открыть. В Windows это будет команда explorer. Этот скрипт можно выполнять в Git Bash, т. е. он для Windows тоже будет работать, если у вас есть Git, а Git есть у всех. 

![](https://habrastorage.org/webt/5u/1f/vw/5u1fvwd8fjgxdbjguwpjsqltrga.jpeg)

Не менее сложный способ подключения с помощью Java Flight Recorder.

![](https://habrastorage.org/webt/74/x0/lg/74x0lgzta9-bxfhnxccs6q_sd88.jpeg)

Его лучше всех описал в статье на Habr Виктор Вербицкий. Статья называется «Управление Java Flight Recorder». И опции, которые я пробовал, как раз подчерпнул из этой статьи. 

![](https://habrastorage.org/webt/ia/ca/_w/iaca_wwhji4mt9fhs_end_pcx80.jpeg)

Основные – это две опции: это StartFlightRecording и FlightRecorderOptions. В этом случае нет интерактивного подключения с помощью Mission Control. 

- Вы говорите, что метрики нужно собирать и писать на диск, не хранить в оперативной памяти. 

- Чтобы дисковая квота не переполнилась, задаете какое-то ограничение, например, 1 гигабайт. 

- Перечень событий, который нужно собирать, загружаете из файлика, путь к которому указываете в этом параметре. 

- Говорите в какой каталог сохранять. 

- И можно еще некоторые опции задать, например, максимальный размер одного файла. Если вы будете запускать с настройками семплирования по умолчанию, то при задании максимального размера файла в 1 мегабайт, фактически будет 2-3 мегабайта. Потому что после сбора метрик, т. е. когда они в сыром виде собрались на мегабайт, из записи этого сбора записываются еще дополнительные события, и файлик становится чуть больше. Если вы собираете помимо стандартных реплик еще метрики по памяти, то при задании maxchunksize=1m размер результирующего файла будет 300 мегабайт. 

- И еще полезная опция stackdepth. Глубина stack по умолчанию 64. И для spring-boot приложения, где stack очень огромный, вы не увидите, где у вас узкое место. И рекомендую его увеличить. 


![](https://habrastorage.org/webt/ub/j0/ne/ubj0necvh_vji9tgwvvzcm7hyb8.jpeg)

- Все опции семплирования для JFR, которые задаются в filename, мы можем посмотреть, как они выглядят по умолчанию в файле jre\lib\jfr\default.jfc.

- Это простой файл в формате XML. 

- Но его можно редактировать в JMC. 


![](https://habrastorage.org/webt/2e/6m/dx/2e6mdx4ugb6wbhuhnpgrpb_aoq0.jpeg)

Если вы хотите сделать процесс профилирования, то там будет кнопка Template Manager. Нажмите ее, откроется Flight Recording Template Manager, где вы можете сдублировать существующие профили, отредактировать их, нажав «Edit» или экспортировать в файл. А потом этот файл замонтировать в поду и использовать. 

![](https://habrastorage.org/webt/po/j9/yw/poj9ywslknhwfqia-lt0_lxniem.jpeg)

Если вы вообще ничего не замонтируете, то можете использовать настройки по умолчанию. 

![](https://habrastorage.org/webt/rh/kd/2-/rhkd2-gnkwkkdfgj_zeqtnfjxx4.jpeg)

Если у вас есть какие-то пожелания по выбору метрик, то вам нужно смонтировать также, как и для агента каталог. Это необходимый для вас файлик. И нужно подключить этот файлик в опциях JVM. 

![](https://habrastorage.org/webt/t6/jx/pd/t6jxpdxn4vl2cxkivhe3v_el5hs.jpeg)

Вот так можно называть каталог, в котором будут опции. 

![](https://habrastorage.org/webt/hf/2l/5x/hf2l5xhlfcv2v2cod4fhrrvpbvq.jpeg)

Вот так его подмонтировать.

![](https://habrastorage.org/webt/xk/pl/pm/xkplpm5tvpjon4gv2nelihg_v_y.jpeg)

И вот так указать этот путь: filename /tmp/jfr/prof.jfc.

Вот такой способ подключения JFR.

![](https://habrastorage.org/webt/qp/un/zp/qpunzpf7nuubt3cuc4p1nfh1fhi.jpeg)

С помощью JavaAgent тоже можно все локально делать самыми разными профайлерами. Я, правда, не пользовался, поэтому и рассказывать вам не буду. 

![](https://habrastorage.org/webt/3s/w3/gn/3sw3gn3xlpovg0sjupphnyruals.jpeg)

И есть очень интересный способ, как все сделать на лету. Он обещает, что вы можете в любую поду зайти и начать профилирование. 

Сложность в том, что у меня этот способ сработал ровно с одним профайлером и не сработал со всеми остальными. 

В чем суть? Чтобы все это на лету сработало, вам нужны инструменты разработчика, т. е. не просто Java Runtime Environment, а JDK внутри контейнера. А все стремятся сделать контейнеры легковесным, никаких дополнительных инструментов и утилит в контейнере нет. Я пробовал это сделать, но у меня ничего не получалось. А с Async Profiler получилось.

Его фишка еще в том, что он может не только stack traces собирать, а собирать большее количество метрик более точно.

![](https://habrastorage.org/webt/o9/fw/jo/o9fwjoolqwws48ct5887vx17r0q.jpeg)

Поэтому на него я бы хотел обратить особое ваше внимание. 

![](https://habrastorage.org/webt/vj/al/3u/vjal3u2eiujudv9ahpiibzwlwjq.jpeg)

Разработал его Андрей Паньгин. И в Async Profiler я могу отметить наилучшую поддержку Alpine Linux и не только. 

![](https://habrastorage.org/webt/3z/uz/_z/3zuz_z2y0qzcx7xbny9kjsqg4wk.jpeg)

Что это за штука Alpine Linux? Почему на нее нужно обращать внимание? Если вы зададитесь вопросом: «Какие Linux-дистрибутивы и с какими опциями используются в ваших контейнерах?», то вы, скорее всего, зайдете на Docker Hub, начнете выбирать контейнеры, которые у вас будут базовыми для ваших сервисов. 

![](https://habrastorage.org/webt/ya/c8/8r/yac88rc-d4iihfpev1wownmkn8g.jpeg)

И у вас будут некоторые факторы выбора их. 

![](https://habrastorage.org/webt/zf/lf/s2/zflfs29vwbepgzygjfbhl2ufsyq.jpeg)

Среди них – это операционная система, т. к. они бывают разными. А также – JDK или JRE, какая там версия. Можете обращать внимание на популярность. 

![](https://habrastorage.org/webt/d0/mn/nh/d0mnnhuri3shibagmsqugbakkou.jpeg)

Я зашел и составил табличку для тех контейнеров, которые используются у нас на проекте. 

По статистике среди пользователей Docker Hub наиболее популярный дистрибутив – это CentOS. Наиболее популярная версия – Java 8.

![](https://habrastorage.org/webt/i5/vc/72/i5vc72253g8osgtac34q2xr0rhs.jpeg)

На нашем проекте первое место совпадает с этой статистикой. А второе место – это Alpine. 

И в разделении CentOS против Alpine есть важный фактор для инженера производительности при выборе профайлера. При выборе профайлера вам нужно будет выбирать Linux-musl различные инструменты, которые содержат слово «musl» в своем названии. 

![](https://habrastorage.org/webt/6u/9b/q1/6u9bq1xvdugeaiioovskosbmja0.jpeg)

При скачивании Async Profiler нужно выбрать нужную сборку. У него есть сборки и для Macos, и для самых разных Linuxs. У вас будет выбор между x64 и musl. 

![](https://habrastorage.org/webt/y2/sj/xf/y2sjxfunobdyxmbndq5wt5wgsdu.jpeg)

И как вы заметили, внутри Alpine есть JDK. Это популярный дистрибутив. У нас он тоже встроен. 

И я пытался пользоваться утилитами JDK из контейнера, и оказалось, что они не работают. Все-таки Alpine-дистрибутив урезанный. Несмотря на то, что там есть утилиты, ими нельзя воспользоваться. 

Я расстроился, что вообще никакого шанса нет, но оказалось, что в Async Profiler есть замечательная утилита jattach. 

Она выполняет функции jcmd.

![](https://habrastorage.org/webt/oe/pn/f9/oepnf9-m8caimaxdzwn4lvyctpi.jpeg)

Его особенность в том, что нужны ROOT-права и они не всегда есть. Но если они есть, то все получится. 

![](https://habrastorage.org/webt/nm/kl/tq/nmkltqjde2ftyxoy1m3mciyy-ce.jpeg)

Вот такая сложная получилась схема, как подключиться и начать профилирование. Надеюсь, она вам когда-нибудь пригодится в жизни, и вы сэкономите свое время. 

Рассказывая про удаленное профилирование, я немного затронул тему того, что иногда можно запрофилировать две поды, а иногда одну. Это тоже важный аспект профилирования в Kubernetes. 

![](https://habrastorage.org/webt/hr/ct/n1/hrctn1b8ga9gwf0bjm5s0zo_3aq.jpeg)

Но он все-таки зависит не от того способа профилирования, который вы выбрали, а от другого момента. 

![](https://habrastorage.org/webt/xf/n0/ag/xfn0agcdndmfphsp5hos_gkimqm.jpeg)

Если ваш дефект производительности проявляется при единичном запросе, при ручном, то тут один способ масштабирования и подбора инструментов.

Например, вы в браузере тыкаете на ссылку, и ваш сервис зависает.

![](https://habrastorage.org/webt/ho/cg/ap/hocgapt1kizx3jhtbyr5dvilyge.jpeg)

Чтобы найти узкое место в таком сервисе, вам не нужно 10 реплик, достаточно одной. 

![](https://habrastorage.org/webt/bw/ks/om/bwksomzy199yzw60kl0ic_o64u4.jpeg)

И ее можно профилировать максимально детально с инструментацией, с использованием Java-агентов.

![](https://habrastorage.org/webt/zl/zj/dr/zlzjdrhhaij26bkpursynqz5dok.jpeg)

А также с помощью таких инструментов, как JProfiler, YourKit для детального сбора метрик по всем аспектам. 

![](https://habrastorage.org/webt/si/id/-s/siid-s2eymkoazohnqunb1kiory.jpeg)

А если для профилирования вам надо подать большую нагрузку, а при большой нагрузке, как правило, нужен более большой кластер, например, 5 реплик выдерживают такую нагрузку, то в этом случае рекомендую оставить все 5 реплик, но к ним добавить 6-ую реплику для дополнительного масштабирования. И 6-ую начать нагружать. 

![](https://habrastorage.org/webt/h2/sg/i_/h2sgi_g_lpr6610kmwsw-umdyca.jpeg)

Если от данного сервиса зависят другие сервисы, то из всех созданных 6 реплик рекомендую профилировать только одну, чтобы 5 других не замедлялись. 

![](https://habrastorage.org/webt/ai/dm/ey/aidmeyyktf7meevqmrmlk1i6jkc.jpeg)

Это у меня на схеме отмечено, как быстрое выборочное профилирование. 

![](https://habrastorage.org/webt/lt/eb/-w/lteb-wvoyigitgcpqtfzjvt1ukg.jpeg)

Тут выберите такие инструменты, как JDK или Async Profiler. Они создают наименьшую нагрузку на профилирование приложения. 

Если у вас задача запрофилировать все поды с небольшим overhead, то можете выбрать те же самые инструменты или сделать массовый запуск JFR.

![](https://habrastorage.org/webt/j8/od/rq/j8odrqd_m2nqwahrj4wmynw2zqw.jpeg)

Решая вопрос, какое количество под, сервисов профилировать, идите по пути наименьшего сопротивления. 

Если у вас есть возможность использовать тяжелый профайлер, то используйте его в одной реплике. Если вам нужно много реплик, то используйте более легкие инструменты. Если у вас есть ROOT-права, то используйте Async Profiler. Если у вас нет ROOT-прав, то JDK. Если у вас достаточно новая OpenJDK и там есть поддержка JFR, то попробуйте его. 

![](https://habrastorage.org/webt/et/y_/bs/ety_bsgjdwms52f_lqugxbt6bya.jpeg)

Надеюсь, я рассказал все про подключение и особенности Kubernetes и роли профилирования в нем. И некоторые части пазла у вас сложились и осталось совсем немного белых пятен. 

![](https://habrastorage.org/webt/eu/fx/om/eufxomk6kqh3jtun43ep0qdym9m.jpeg)

Сейчас быстро расскажу, как анализировать результаты. 

![](https://habrastorage.org/webt/3u/tm/ew/3utmewzqhydphd3y2dwctwuiapi.jpeg)

Самая частая у меня задача – это анализировать результаты семплирования.

1. Первый шаг – это визуально оценить работу потоков.
2. Собрать статистику по работе потоков. Т. е. мы посмотрели визуально, оценили это в виде чисел. 
3. Выбрать из всех этих потоков только проблемные, исключить непроблемные. 
4. Детально собрать статистику только по проблемным. 
5. И разделить на методы прикладные. 
6. Т. е. тут у нас Postgres тормозил, тут какой-то http-запрос. 
7. И наложить эту статистику на исходный код.

Вот такой семишаговый процесс. 

![](https://habrastorage.org/webt/6g/8i/id/6g8iid1wlognz4xrjj9lhcmlgzg.jpeg)

Первый этап – визуальная оценка. Этот этап очень важен. 

![](https://habrastorage.org/webt/me/fs/mm/mefsmmifese-nvv4qhwf800a6ck.jpeg)

Его можно сделать в бесплатном инструменте JVisionVM.

![](https://habrastorage.org/webt/87/xc/9d/87xc9d96odydv0nq0uheag9zn-k.jpeg)

Если вы посмотрите на свои потоки и увидите, что они параллельно работают, то у вас нет проблем с параллельностью. Вы создали 20 или 120 потоков, и они как-то параллельно живут. 

![](https://habrastorage.org/webt/en/hp/5f/enhp5fhj_mrtusqxqh2_qse-hxk.jpeg)

В этом случае вы будете сосредоточены на анализе эффективности, на работе каждого отдельного потока. 

![](https://habrastorage.org/webt/ud/f9/yw/udf9ywwiibgeapsycsddvvt5-m0.jpeg)

А бывает другая картина. Вы смотрите визуально в JVisionVM и видите, что ни один поток параллельно с другим не работает. И даже если кажется, что они накладываются, то это не так. 

![](https://habrastorage.org/webt/yi/h3/x1/yih3x100yimhxi_vvxmraa3fz78.jpeg)

В этом случае у вас совсем другая проблема. 

![](https://habrastorage.org/webt/yd/ip/9c/ydip9cjizxycg0grloiqailbq_m.jpeg)

Система работает медленно не из-за недостатка масштабирования, а по причинам блокировок. И вам нужно анализировать уже этот момент. 

![](https://habrastorage.org/webt/-m/md/wa/-mmdwagmbs5dad1o0roke2fo45u.jpeg)

Еще замечу, что при выборе потоков важно ориентироваться в них хоть немножко. 

![](https://habrastorage.org/webt/cn/kv/tx/cnkvtxbjfon4omopuneua88mhds.jpeg)

Статистику достаточно смотреть по ключевым местам. И совсем не смотреть, например, по JMX и RMI. Это RMI Scheduler, RMI TCP Accept, RMI TCP Connection. Kafka Heartbeat обычно не доставляет проблем. И различные потоки, которые отвечают за сборку мусора, тоже нам не интересны. 

Нам достаточно посмотреть, какой вес они занимают в процессе профилирования, т. е. в работе сервиса, но не нужно залезать в детали, потому что мы ничего там не поменяем. Если только вы заметили, что поток сборщика мусора выделяется из всех потоков, то посмотрите на настройки сборки мусора. 

![](https://habrastorage.org/webt/uq/do/nz/uqdonz_zn-izrqb79_jaa8yvfuu.jpeg)

А заглянуть внутрь нужно уже при таких потоках: http-nio-8080, Thread-pool, OkHttp, WebSocket.

![](https://habrastorage.org/webt/0i/bc/r8/0ibcr8sgpmbqvbgp2e-um8wj2aa.jpeg)

Как это делается в больших профайлерах? 

![](https://habrastorage.org/webt/sl/id/tm/slidtmvla5h1gvf9pf4ys1e1nmk.jpeg)

В том же JProfiler рекомендую зайти в Thread History. Там можно увидеть диаграмму работы потоков. Выбрать самый тяжелый. И перейти по пункту Show Call Three Selected Thread. 

Недостаток или особенность JProfiler в том, что для двух потоков эту статистику собрать нельзя, т. е. нельзя объединить. 

![](https://habrastorage.org/webt/j3/em/-w/j3em-whzfq4dt-vugi_hxw29yls.jpeg)

Но такое можно сделать с помощью других инструментов. 

![](https://habrastorage.org/webt/ky/s2/h2/kys2h2jpjkpwyj7vhhcwrbc6fd0.jpeg)

С помощью того же JDK. 

![](https://habrastorage.org/webt/bd/07/dm/bd07dm_dgkr_6z0r8iw4rctjvym.jpeg)

Я на слайдах привел пошаговые готовые скрипты, которые вы сможете использовать у себя, чтобы объединить статистику.

![](https://habrastorage.org/webt/rn/yt/rp/rnytrpisfys9nc5abnhjpn68n_y.jpeg)

И построить в диаграмму. 

![](https://habrastorage.org/webt/t-/4o/ml/t-4omltjqghlnkaawbqgtdpbmeq.jpeg)

Диаграмма – это такой красивый график. 

![](https://habrastorage.org/webt/zr/qq/49/zrqq49ny2fmtcq2dfrp-habagia.jpeg)

Кроме того, он будет снабжен статистикой уже с номерами строк. 

![](https://habrastorage.org/webt/ed/p-/au/edp-aua3lc_k0cthfxjxyr6rchw.jpeg)

А если вам нужно из всей работы потоков выделить отдельный метод, то это тоже возможно. 

![](https://habrastorage.org/webt/ix/tr/em/ixtreml4kaei5ulcqumwmyx7_mq.jpeg)

Вот вы смотрите на эту большую flame-диаграмму. 

![](https://habrastorage.org/webt/nx/id/tf/nxidtfhgiwfoabgdsgo1ni0ib6g.jpeg)

Она может показаться на первый взгляд непонятной.

![](https://habrastorage.org/webt/-r/yl/-2/-ryl-2vzokc1pwkehczpbpn-z30.jpeg)

Давайте к ней приглядимся.

![](https://habrastorage.org/webt/fr/pd/vj/frpdvj6x5dyqj8q-xyq4tll2tji.jpeg)

Вот мы приглядываемся-приглядываемся и понимаем, что у нас есть post-запросы и get-запросы. Вот в данном случае есть post-запрос, есть get-запрос. И это уже нам позволяет как-то сориентироваться и выделить наши запросы среди всех. Т. е. смапить их на некоторые бизнес-задачи.

![](https://habrastorage.org/webt/ml/uc/hv/mluchv-uc8klvq03ceempuk6cvy.jpeg)

Наши запросы, как правило, выделяются по префиксу. Если наша команда называется ВТБ, то вот наши прикладные методы. Вот ru.vtb.dbo и т. д.

![](https://habrastorage.org/webt/fp/nj/wl/fpnjwliubi8qauwjkhrewugfpjy.jpeg)

Кроме этого, есть имя самого запроса. 

![](https://habrastorage.org/webt/7o/an/ar/7oanarve-p5l5sex9mx-3aqtqu0.jpeg)

Вот оно: organizationsSearch. 

![](https://habrastorage.org/webt/ep/pt/qf/epptqfjvel_vyvupgkji6j26uss.jpeg)

Все эти три признака позволяют из stack traces выделить интересующие вас участки.

![](https://habrastorage.org/webt/lm/bt/na/lmbtnaa5niwew7sz-a7lriaexwu.jpeg)

Фишкой JDK является то, что можно объединить фильтры, т. е. ряд фильтров накладывать на собранные stack traces и таким образом автоматизировать выделение статистики по отдельному методу.

![](https://habrastorage.org/webt/yk/rd/qa/ykrdqacggepipmm_2dvp7fly5ia.jpeg)

Вот таким несложным скриптом у вас это получится сделать.

![](https://habrastorage.org/webt/a_/sw/ls/a_swlss32pli6b1d7ascin7n4eo.jpeg)

И после этого можно даже накладывать на эти отдельные методы еще дополнительные фильтры.

![](https://habrastorage.org/webt/yp/sv/ny/ypsvnyf7yr7ib_hfz25enj_f4aa.jpeg)

Вот такие. Тут уже trace-filter. И можно сказать, какую долю в этом методе занимает PostgreSQL.

![](https://habrastorage.org/webt/es/bx/f2/esbxf2kot34p-xx9xemz-lvhib0.jpeg)

Или, наоборот, без PostgreSQL. За счет таких фильтров вы можете оценить взаимодействие текущего сервиса и текущего метода с другими сервисами и с другими компонентами. 

![](https://habrastorage.org/webt/v8/ce/2j/v8ce2j_9upd8dtb0rhp6gyax-5i.jpeg)

И после всего этого у вас получится автоматическое формирование отчета с разбивкой по методам, потокам, классам и другим интересующим вас моментам. 

![](https://habrastorage.org/webt/3v/_f/f0/3v_ff052tx42jn7nfnqkhdhxuwu.jpeg)

Это все, что я хотел бы вам рассказать про анализ метрик. Надеюсь, у вас еще меньше белых пятен осталось. 

![](https://habrastorage.org/webt/fr/pc/ia/frpciayq0wc4xi9qzzwbjmvbyau.jpeg)

И финальный шаг – это как масштабировать профилирование на всю команду. Об этом расскажу быстро.

![](https://habrastorage.org/webt/hx/p2/4n/hxp24ndpklksbmoeztmxl0wdjjg.jpeg)

Первое, что я вам рекомендую делать, это если вы разобрались в профилировании и успешно нашли какие-то дефекты с помощью профайлера, - напишите самый подробный отчет результатов вашей работы. 

![](https://habrastorage.org/webt/r0/be/i1/r0bei1ks8o-r_fbvmceorp_npf8.jpeg)

Вот я пишу суперподробный отчет по профилированию. В шапке есть отчеты по бизнес-составляющим, которые прочитают все. Это какую версию мы тестировали, какие дефекты нашли и какие узкие места были или не были. 

Ниже этой шапки, ниже бизнес-составляющей есть пошаговый процесс, какие окна я посмотрел, какие потоки смотрел, почему я решил, что это узкое место. Эту часть уже не будет читать никто: ни разработчики, ни менеджеры. Но ее прочитают ваши коллеги, которые при следующей итерации регрессионного тестирования, возможно, захотят проверить осталось ли это узкое место. Таким образом ваш подробный отчет – это своеобразная инструкция для ваших коллег. Это обучающий материал.

![](https://habrastorage.org/webt/xx/rn/1w/xxrn1w2s6iu7b9iehqnya7qqkwa.jpeg)

Кроме обучающего материала нужно написать саму инструкцию. 

![](https://habrastorage.org/webt/rp/ya/40/rpya40swjqdveohidlfkuyf3e8y.jpeg)

Первым делом рекомендую написать инструкцию, как выполнить профилирование в ручном режиме. Я вам рассказывал про Alpine и о том, как посмотреть версию, и т. д. Все это нужно задокументировать в том же Confluence. 

![](https://habrastorage.org/webt/c5/mc/ml/c5mcmlgnk6vdat6o_n4p9v6gytu.jpeg)

Инструкцию нужно не просто записать и сохранить в Confluence, а еще и снабдить видео. Я понял, что это важный шаг. 

![](https://habrastorage.org/webt/6n/4w/-g/6n4w-gnqiyglhtfc0vclwaed1yy.jpeg)

И вот моя суперпростая диаграмма, что же делать, если вы написали инструкцию. 

Если вы написали инструкцию и решили замолчать о ней, то это неправильный вариант. Надо рассказать о ней. Если вы решили рассказать об инструкции и в где-то в чате скинули ссылку, то это тоже неправильный вариант. Вам нужно скинуть ссылку и прямо по шагам пройтись по инструкции, записав коротенькое видео минуты на 2. Что вот это я открываю, сюда кликаю, потому что кому-то проще воспринимать такой формат. 

![](https://habrastorage.org/webt/ih/kw/6y/ihkw6ykhtfn4xd3dl--2zshsl-g.jpeg)

И среди тех, кому проще воспринимать такой формат, найдутся те, кто не сможет это сделать с первого раза. И тут я рекомендую вам парное профилирование и анализ результатов профилирования. 

![](https://habrastorage.org/webt/pd/5l/fx/pd5lfxbnv9c07cxmegiky0lfoae.jpeg)

Т. е. кроме того, что вы рассказали инструкцию о том, что она существует и, возможно, даже записали видео, приложили скрипты, попробуйте спрофилировать какой-то сервис чужими руками. По Skype подключитесь, пусть он расшарит экран. И он будет выполнять все эти действия с вашей помощью, с вашими подсказками, но сам. В этом случае это сильно отложится в памяти и будет большим подспорьем для человека.

![](https://habrastorage.org/webt/-e/u4/c9/-eu4c95cm2dg8hrk5wfrg3ohbdo.jpeg)

И последний шаг – это записать все в виде скриптом автоматизации, чтобы это выполнялось как-то совсем просто. 

![](https://habrastorage.org/webt/ht/gp/cu/htgpcu303cw7nimg3mi114fnqmc.jpeg)

Как вы поняли, автоматизировать надо не сильно много вещей. 

![](https://habrastorage.org/webt/ll/tv/ts/lltvtsd4ihdl48bfjthcoevyu2i.jpeg)

Нужно примонтировать, загрузить какие-то файлы в поду. 

![](https://habrastorage.org/webt/if/3c/vm/if3cvmcusuyktyj41vwqwv0_ida.jpeg)

Нужно поменять Java options. 

![](https://habrastorage.org/webt/pp/xx/0y/ppxx0yi2f6viesaw5q5scmxl1mu.jpeg)

Запустить процесс профилирования удаленно, локально. 

![](https://habrastorage.org/webt/ry/eg/zb/ryegzb1fkppn1nllxloiqzjd9le.jpeg)

И потом скачать результаты. 

![](https://habrastorage.org/webt/4q/gb/0x/4qgb0xshn5lxnuc3eyuqb9j6xxi.jpeg)

Как вы понимаете, все это в Kubernetes возможно, например, с помощью Kubectl.

![](https://habrastorage.org/webt/zv/nj/6q/zvnj6qffcio68biuzjgsxjr0bau.jpeg)

А также с помощью Web-дашборда, который есть. Там, конечно, не совсем тривиальный способ будет по скачиванию результатов, но отдельные шаги можно реализовать. 

![](https://habrastorage.org/webt/lm/2c/nl/lm2cnlzge9lu-3-oqq6dmbhtclo.jpeg)

Или какие-то другие инструменты использовать. Мне понравился Lens.

![](https://habrastorage.org/webt/ks/oy/so/ksoysogjqnxxcjeyhsuhuzzprq0.jpeg)

Когда вы это сделали и заскриптовали, то к скриптам тоже напишите документацию, потому что программный продукт – это не только код, но и документация к нему. После того, как вы написали документацию, можно считать, что вы что-то заскриптовали.

![](https://habrastorage.org/webt/r3/3o/ph/r33oph19l_ck3ibskjd0-qqqq5m.jpeg)

И когда у вас есть скрипты, неплохо бы поместить это в CI/CD окружение, чем я в текущий момент и стараюсь заниматься. 

![](https://habrastorage.org/webt/0t/gb/gt/0tgbgtakij4edf5oyxuf2x-knfs.jpeg)

На этом у меня, наверное, все. Надеюсь, совсем минимум белых пятен у вас осталось. 

![](https://habrastorage.org/webt/bj/ez/oo/bjezoonjmvwwgoliudblncmktsw.jpeg)

Я вам рассказывал про то, что с переходом на микросервисы задач меньше не стало. Тут появилось много особенностей Kubernetes’а. Вам нужно профилировать больше сервисов.

![](https://habrastorage.org/webt/rf/cm/bn/rfcmbnisl78ihsu2va5j0atkulo.jpeg)

Топ-3 советов для Kubernetes такие:

1. Начали профилирование, добавьте чуть-чуть ресурсов и задайте какие-то границы для этих ресурсов. 
2. При большой нагрузке лучше использовать семплирование локально, чем инструментацию удаленно. 
3. И важный момент про Alpline. Я не знал раньше про такую особенность, что musl реализации инструментов как раз для него, а Alpline сейчас популярен. 

![](https://habrastorage.org/webt/d_/gr/pi/d_grpigjqmd2hy-1pwebcx_8maq.jpeg)

При выполнении анализа результатов профилирования стремитесь идти от крупного к мелкому, т. е. дробите-дробите. 

![](https://habrastorage.org/webt/qp/hh/zn/qphhzndfso8nve9ftd63ncckco4.jpeg)

- Сначала оцените все визуально. 
- Соберите статистику. 
- И перейдите к деталям. Возможно, отфильтруете что-то по обращению в другие сервисы. 
- JProfiler и YourKit могут перехватывать SQL и HTTP-запросы.
- С SJK несложно автоматизировать процесс формирования отчета. 
- И с JDK тоже такое можно. 

![](https://habrastorage.org/webt/xh/v-/ge/xhv-gezaesqmvbvlydr4_1mhg9q.jpeg)

Обмен знаниями – это очень индивидуальный процесс. 

![](https://habrastorage.org/webt/ip/9g/-e/ip9g-egv9ik9ygljw4v3fglwruk.jpeg)

- Документируйте все, что делаете. 
- Будьте терпеливы, когда объясняете и передаете знания. 
- И стремитесь делать так, чтобы при следующей итерации вам не нужно было повторять все снова, чтобы это было как-то автоматизировано. 

![](https://habrastorage.org/webt/gq/lv/bj/gqlvbjh-0ilbyr7jmbyjszvz0wy.jpeg)

На этом у меня все. Я вам рассказывал про профилирование. Если у вас есть вопросы, я буду рад ответить на них. 

-   (Владимир Ситников) У нас времени осталось мало, поэтому будут блиц-вопросы. Тебе Kubernetes нравится: да или нет?

-   (Вячеслав Смирнов) Нравится. 

-   Профилировать Kubernetes нравится?

-   Не очень. 

-   На монолит вернешься?

-   Нет, не получится.

-   Java или Go?

-   Я пока что знаю только Java.

-   Alpine или нет?

-   Наверное, нет, слишком он урезанный. 

 
